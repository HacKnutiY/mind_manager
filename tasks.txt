памятка: 
  прописываем поля/методы в МОДЕЛИ если работаем с данными
  состояния. Например: список целей, который мы вскармливаем билдеру

  прописываем поля/методы в СЕРВИСЕ если данные не относятся к состоянию
  - Функция работает с персистентными данными (Hive, API)
  - Функция содержит бизнес-логику (валидация, преобразования)
  - Функция может быть полезна в нескольких несвязанных модулях

  виджет взаимодействует только с моделью

теперь работаем в таком формате. параллельно работаем с моделью
цели например и экраном где эта цель используется - activities
1. прописаываем в модели методы-сценарии
2. дробим эти сценарии на подфункции
3. разбираем: если функция работает не с данными состояния и 
часто будет исполььзоваться и на других экранах - перекидываем в сервис  


задачи:
- мне кажется неправильным сущесвтование менеджера актуальных целей.
менеджер долгосроных - да, но актуальные - лишний слой 
Ну с дальнейшими шагами вот и разберемся что туда внести
- actualTermGoals - список который находится только на одном экране => 
вынести все с ним связанное в моделью
- так, теперь





- бокс долгосроков направлений(тоже отдельный бокс на каждое направление) открывать как и заметки
1 для начала нужно создать объект направления
2 для каждого направления - свой бокс целей , а для актуальных целей - свой бокс
  2.1 создать объект цели(сделано)
  2.2 обеспечить правильную навигацию с передвчей ключа направления. Вопрос - через конструктор или навигатор 
  передать -> через конструктор в инит стейт, далее обращаемся через widget, так как конструтор  
  виджетовский(очевидно) (сделано)
  2.3 по этому ключу уже инициализируем модель (сделано)
  2.4 написать билдер виджета целей (сделано)
  2.5 теперь через модель можно открывать бокс и добавлять туда объекты (сделано)
  2.6 Напиши загрузку целей из бокса (сделано)
  2.7 Закрытие бокса. Но для этого нужно поменять инхерит на changeNotifier
  2.8 удаление бокса при удалении направления (сделано)

//--- На этом этапе я выжал знания и техники котрые смог из проекта по списку дел
и план такой : из gh склонирую свой старый проект и продолжу его пока не дойду до темы архитектуры
паралельно добавляя в свой проект детали которые необходимы + заполняя ответы для собеса

  2.9 добавил в бокс направления - добавь и в актуальный бокс
  2.10 напиши валидацию для полей
3 удалив(/завершив) из бокса целей, мы должны удалить и из бокса напрваления 
4 когда закончится срок цели направления мы тоже должны удалить из актуал бокса тот же самый объект
и тут появляется вопрос как это реализовать
- отдельный бокс актуальных целей - при добавлении цели в бокс долгосрока направления,
туда тоже добавляется эта цель, тоже самое при удалении. сгенерим отдельно имя бокса, а затем (имяБокса_ключОбъекта)
при таком сценарии надо будет билдер дергать постоянно, чтобы поля ключей изменились


------------
ЗЕМЕТКИ И ВОПРОСЫ

поговорим о инхеритед нотифаер
1. Объявить инхерит. Передать ему в родительский конструктор параметр нотифаер типа changeNotifier
2. Сделать его родительским для виджетов, по которым будем проносить данные
3. Обращаемся к модели в инхерите посредством методов контекста по поиску по дереву. Можно подписаться с 
подпиской и без. поиск без подписки полезен в случае когда из модели нужны константы или какие то методы модели;
с подпиской в случае когда за изменениями данными в моделе нужно следить и менять
4. НотифайЛистенерс. метод перерисовывает только подписанные на него виджеты

почему же даже при использовании инхеритед нотифаер использовали фул виджет
наша задача в чем? - сохранить состояние объявленной модели(changeNotifier), чтобы ее поля не обнулились
прописать переменную модели в билде заведомо странное решение и это очевидно, даже разраб не знает сколько 
раз перевызвоится билд. 
далее, что насчет того чтобы прописать его в поле лесс виджета? в таком случае виджет перестроиться вместе с нашей 
моделью в случае если перестроиться родительский виджет .
ну тогда и остается фул виджет. потому что мы прописываем это поле не в самом виджете, а в его состоянии. 
То есть это поле наша модель уже будет полем состояния. А состоние строится только один раз - при initState()   


где прописывать получение аргументов с другого экрана - didChangeDependencies. ModalRoute - инхерит потому что
но не всегда. можно и в инитСтейт, но тогда уже передача через конструктор проводится

------------

