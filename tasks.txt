фичи:
0. пробуем написать валидацию(например при созлании задачи) с помощью ключа
+ изучение данной темы
1. круд. играем с разными подходами смены состояния, ищем их + и -
1. добавить поиск по заметкам
2. активная/неактивная задача. добавить границу
3. темная и светлая тема
---------
рефакторинг на потом:
1. названия методов/полей и тд в одном стиле
3. поменять виджет долгосрока
4. в утилиты вынести часто используемые компоненты:
- виджеты
  долгосрочка
  таска(возможно, разделим обычную и спринтовую)
  поля
  кнопки добавления/удаления
- методы
  валидация полей
  валидация DateTime для нужного отображения в полях
  генерация id
6. правильно организовать работу с боксами. не знаю как именно пока
7. я перекидываю sprintKey с экрана SprintScreen на экран
newSprintTaskScreen прямо во вью слоях. перекиннуть все это в навигатор 
тут я просто перекинул метод приема в модель, проверить реально в навигатор
надо мб
8. удалил направление - не удалились задачи и цели связанные с ним. хотя с другой стороны
не баг а фича
9. нет обновления состояния при удалении долгосрока с экрана направления
10. некоторую работу view модели взял на себя вью. Например на
экране NewTaskScreen
11. рассмотреть шаг за шагом как происходит удаление/добавление таска(спринта). 
можно найти много странностей
12. состояние task не сохраняется при выходе из приложения, тк загрузка данных происходит 
только во время создания, а обновления и загрузка последнего состояния в бокс данных нет впринципе 
--------
баги:

--------
вопросы:

----------
памятка:
  если какая то вью только на одном экране встречается, то можно 
  ей назначитьмодель экрана на которой она находится. очевидно, но да
  прописываем поля/методы в МОДЕЛИ если работаем с данными
  состояния. Например: список целей, который мы вскармливаем билдеру

  прописываем поля/методы в СЕРВИСЕ если данные не относятся к состоянию
  - Функция работает с персистентными данными (Hive, API)
  - Функция содержит бизнес-логику (валидация, преобразования)
  - Функция может быть полезна в нескольких несвязанных модулях

  виджет взаимодействует только с моделью

теперь работаем в таком формате. параллельно работаем с моделью
цели например и экраном где эта цель используется - activities
1. прописаываем в модели методы-сценарии
2. дробим эти сценарии на подфункции
3. разбираем: если функция работает не с данными состояния и 
часто будет исполььзоваться и на других экранах - перекидываем в сервис  

изменено:
по подходу llf
  provider - обращения к сети/лок базам данных
  service - вся бизнесс логика и взаимодействие с провайдерами(сетью/бд)
  viewmodel - тоже логика(посредством обращения к сервису и слизывания уже готовых методов) 
  и данные, преобразованные в подходящий для view вид
  view - максимально тупой компонент, задача которого - отображать данные 
  которые передал viewmodel
тогда вопросы:
  в провайдере может ли храниться список ValueListener, на который 
  должен реагировать (моделька,а за ней) билдер


provider в качестве основого state managment, valuenotifier 
дополнительный


доработал задумку mind_manager, и он стал сложнее.
что поменялось:
1) Вид виджета спринта. Теперь это - выпадающий список среднесрочных целей
2) Виджет цели спринта - среднесрочные цели. Теперь, сущности в выпадающем списке - карточка
Цель можно выполнить и по ней перейти на экран создания задачи
3) Виджет таска. Теперь таск тоже выпадающий виджет, в нем уже могут храниться подтаски
и таски и подтаски - чекбоксы
экран создания спринта не меняется

1 этап: изменение виджета спринта:
- при обычном нажатии выпадает список целей на спринт
- при долгом - экран спринта. на этом экране можно удалить и изменить цели

 
- через спринт можно перейти на экран спринта, на нем будем 
удалять/добавлять таски. а выполнение будет фиксироваться за счет 
чебокса(виджет как и был)



заготовка виджета спринта готова, и теперь:
1) в модели SprintsScreen подгрузить весь бокс тасков
2) в билдере тасков

+ чет 17-18 строка SprintWidget гит null оператор с null значением когда 
3) удаление таска в спринте за счет свайпа

4) в newSprintTask должен прилететь (опциональный) аргумент с 
экрана существующего спринта. далее его поместим в метод сохранения 
SprintTask 

!!!
2)относительно удаления таска спринта с экрана newSprintTask именно когда 
мы создаем новый спринт: я прописал что при удалении таска спринта он 
удялается с бокса тасков, и забыл, что при создании нового спринта я 
таски сначала закидываю в лист (нотифай вэлъю), а не сразу в бокс
ну тут скорее всего просто придется параллельно с листа удалять таску 
+ связанная с ним проблема
1) добавление таска в существующий спринт рабоает, но нужно перебилживать 
экран спринта, чтобы добавленный спринт отобразился (решено)
тут будем использовать методику ValueListenerBuilder + box.listenable
тут  билдеру дать слушатель в виде слушателя бокса таксов спринта
(решено)
---старая проблема
3) короче, основная проблема - не получается вернуть список виджетов в поле children
виджета спринта а за ним notifyList вызвать(тк за ним реторн), но также не могу 
поле отдельное в классе прописать и прописать метод load.. для заполнения 
этого поля, тк нужен ключ.
решение этой проблемы было просто: я внес ValueListenableBuilder 
но с литералами списка(children же список принимает) и все. 
<Widget>[Listenable]. гениально (решено)


----
0) разобраться задачей 2 описанной выше
4) пишу экран задач:
- открыть бокс задач 
- в сервисе прописать поле со слушателем этого бокса
---
- создать экран создания таска












задачи:
удаление цели еще и с экрана направления
  добавить метод удаления в сервис долгосрока
проблема: в виджете долгосрока прописана одна модель
экрана, но сам виджет на разных экранах
решение: не прописывать модель, а одним из параметров
виджета сделать просто методы удаления и завершения
-----------
Задача: добавляем в сервис долгосрока методы удлаения из бокса
и списка
кстати относительно спика - там же слушатель. как то 
через него все это сделать надо же 

проблема: чтобы удалить из сервиса долгсрок из бокса
нужен доступ к боксу(а у нас его нет, то есть 
нет activityKey если речь идет об экране направлений).
решение: все цели в один бокс
с ключом направления
  - поменять структуру долгосрока - добавить поле для ключа направления +
  - запустить билдер и перегрузить приложение чтобы не было конфликтов +
  - открыть бокс долгосроков в main +
  - activity корректная фильтрация целей по activityKey +
  - new_term_goal корректное создание объкта цели и
    добавление его в бокс
  - activity корректное удаление целей при удалении направления 
  - синхронизация списка актуальных и бокса долгосроков
  может прям в activity повесить слушатель а бокс, чтобы при добавлении/удалении
  элементов из него, список обновлялся вместо с ним
  в таком случае методы добавления и удаления не нужны. нужно прописать лишь метод 
  загрузки данных из бокса и вызывать его каждый раз когда дергается бокс 
  - бокс мы навешиваем на экране activities, а первоначальную 
  загрузку пропускаем получается?
  последние 2 проблемы выше решил одним методом loadTerms в сервисе
  - вернемся к удалению актуальной цели. то есть она удаляется из бокса
  вне зависимости где был виджет. тогда все просто просто метод удаления из 
  бокса и нужен, а далее слушатель на боксе просто перезагрузит слушатель 
  списка, но прописать его нужно на каждом экране отдельно, чтобы
  сервис с виджетом не перемешивать
  короче метод в сервис я добавл, и добавил отдельный в activities. 
  щас как я понял понял надо подготовить виджет и закинуть в 
  него параметром этот метод
  - завершение цели
  желаемый результат: при нажатии на кнопку завершения, 
  виджет уходит со списка, но остается в боксе.
  значит: нажал -> виджет удаляется из списка актуальных(+) -> 
  isComplete = true -> кнопка завершения в блок(+)
  -> текст в виджете меняется на актуальность: не актуально(+)
  написать фильтрацию для списка актуальных, чтобы при перезагрузке
  долгосроков он опять в этот список не попал(+)

ТУТ И В ПОСЛЕДУЮЩИХ ЭКРАНАХ ВНИМАТЕЛЬНЕЕ ОТНОСИТСЯ К MVVM
-------экран списка спринтов----------
- создать виджет спринта (+)
- добавить на экран floating кнопку для добавления 
спринта и настроить навигацию на экран создания (+)

------экран создания спринта----------
виджеты
- поля имени, времени начала и конца(+)
- конструктор цели:
---экран создания задачи---
  - текст задачи
  - направление. выпадающий список с выбором существующих направлений
  - при добавлении виджет задачи отображается на экране спринта
-------------------------
логика
- все цели сохраняются в HiveList<Task>(та же задача, по сути) 
объекта Sprint 
- после добавления цели, можно ее удалить 


Задачи
- валидация полей выпадающего списка и поля
- класс Task - один, и для краткосрока и для спринтовых, просто
поле спринтКей опциональное
- написать метод в менеджере боксов для открытия боксов спринтовых задач
  - в константах создать имя для таск бокса(именно для спринтового таска)
- добавить поле списка с задачами в модель new_sprint
- добавить Task в бокс 
- добавить слушатель на бокс спринтовых тасков
- написать билдер на экране нового спринта



СОЗДАНИЕ спринта. без его просмотра
----------Я ТУТ------------------
создать класс спринт + его адаптер
открыть бокс спринтов 
  в константы прописать его имя
  в main прописать условие на наличие адаптера
  открыть бокс
исправить экран конструктора спринта
  - в билдере спринтов заполнить параметр sprintKey
  - при сохранении добавить таск в бокс + заполнить параметр sprintKey
  для него. его взять с виджета спринта с экрана спринтов
  - если все поля заполнены добавить спринт в бокс. 


в модели спринтов прописать loadSprints + навесить на бокс слушатель
  ------------------уже если экран спринта делать-----------
  - нажал на этот виджет - в боксе начался поиск с нужным ключом
  -ключ нашел - высыпал все значения в сервис а потом и в модель 

- архитектурный порядок навети view-model-service (!)
  - работа с бд в сервис.
- построить класс спринт с полями первой и последней даты, имени. при нажатии
на спринт просто перекинь на след экран ключ для подгрузки нужных спринтов

https://flutterawesome.com/flutter-starter-architecture-mvvm-hive/



------------
ЗЕМЕТКИ И ВОПРОСЫ

поговорим о инхеритед нотифаер
1. Объявить инхерит. Передать ему в родительский конструктор параметр нотифаер типа changeNotifier
2. Сделать его родительским для виджетов, по которым будем проносить данные
3. Обращаемся к модели в инхерите посредством методов контекста по поиску по дереву. Можно подписаться с 
подпиской и без. поиск без подписки полезен в случае когда из модели нужны константы или какие то методы модели;
с подпиской в случае когда за изменениями данными в моделе нужно следить и менять
4. НотифайЛистенерс. метод перерисовывает только подписанные на него виджеты

почему же даже при использовании инхеритед нотифаер использовали фул виджет
наша задача в чем? - сохранить состояние объявленной модели(changeNotifier), чтобы ее поля не обнулились
прописать переменную модели в билде заведомо странное решение и это очевидно, даже разраб не знает сколько 
раз перевызвоится билд. 
далее, что насчет того чтобы прописать его в поле лесс виджета? в таком случае виджет перестроиться вместе с нашей 
моделью в случае если перестроиться родительский виджет .
ну тогда и остается фул виджет. потому что мы прописываем это поле не в самом виджете, а в его состоянии. 
То есть это поле наша модель уже будет полем состояния. А состоние строится только один раз - при initState()   


где прописывать получение аргументов с другого экрана - didChangeDependencies. ModalRoute - инхерит потому что
но не всегда. можно и в инитСтейт, но тогда уже передача через конструктор проводится

------------

