13.11
фича добавления списка актуальных целей на главный экран
  написать singleton с ValueNotifier внутри и менять список внутри 
  него уже чтобы из любого места можно было его закинуть ValueNotifierBuilder
  и уже он работал как надо
фича удаления цели
  не важно с какого экрана. суть: нажал на кнопку удаления цели - она удалилась из списка 
  и бокса целей направления. получается нужен некий id с помощью которого виджет удаляется 
  с бокса, да и со списка нужно будет вручную удалять(при удалении с бокса добавить строку изменения)
  судя по всему. 
  - первая задача - решить, нужно менять структуру адаптера и добавить в него id или есть какой то ключ 
  у элементов и через него и производить удаление . один из возможных вариантов - создать все таки поле id
  а в него вписать ключ операции hive 


1) удалил цель из направления - она удалилась из общего(актуального) бокса тоже
2) завершил цель - она удалилась только из актуального бокса
------
- singleton List<TermGoal> - сделано
- добавить в actual цели в тех методах где добавляются в боксы
целей направлений 
- ValueNotifier для обновления списка актуальных + получу ответ на 
вопрос
- в ините модели activities прописываем закачку данных в List<TermGoals>
- с фильтром от завершеных целей 
- опустошить все боксы, так как будем менять структуру адаптера цели -
добавляем id, isComplete
- 1 аспект: удалил цель из направления - удаляем по id ту же 
цель из списка
- 2 аспект: завершил цель - удалил из списка по id
приходят мысли о том где прописывать эти методы - в модели цели или экрана


вопрос:
если вызвать notifyListeners у экрана который еще неактивен, 
как будет производиться перерисовка

идея: 

1 - этот ValueNotifier статическим делать. и вообще в чем именно
суть статического поля


Короче решение:
- бокс направления открывать при запуске приложения, тк направлений по сути
не так уж и много должно быть (сделано)
- бокс заметок открывать при открытии экрана этого направления, закрывать при выходе 
с экрана направления (сделано)
- Удалить слушатель (сделано)
Короче вспомнил про то что при удалении направления должен удаляться и бокс заметок, но в dispose прописан 
код который ЗАКРЫВАЕТ этот самый бокс заметок посоле его удаления получается -> конфилкт(сделано)


- бокс долгосроков направлений(тоже отдельный бокс на каждое направление) открывать как и заметки
1 для начала нужно создать объект направления
2 для каждого направления - свой бокс целей , а для актуальных целей - свой бокс
  2.1 создать объект цели(сделано)
  2.2 обеспечить правильную навигацию с передвчей ключа направления. Вопрос - через конструктор или навигатор 
  передать -> через конструктор в инит стейт, далее обращаемся через widget, так как конструтор  
  виджетовский(очевидно) (сделано)
  2.3 по этому ключу уже инициализируем модель (сделано)
  2.4 написать билдер виджета целей (сделано)
  2.5 теперь через модель можно открывать бокс и добавлять туда объекты (сделано)
  2.6 Напиши загрузку целей из бокса (сделано)
  2.7 Закрытие бокса. Но для этого нужно поменять инхерит на changeNotifier
  2.8 удаление бокса при удалении направления (сделано)

//--- На этом этапе я выжал знания и техники котрые смог из проекта по списку дел
и план такой : из gh склонирую свой старый проект и продолжу его пока не дойду до темы архитектуры
паралельно добавляя в свой проект детали которые необходимы + заполняя ответы для собеса

  2.9 добавил в бокс направления - добавь и в актуальный бокс
  2.10 напиши валидацию для полей
3 удалив(/завершив) из бокса целей, мы должны удалить и из бокса напрваления 
4 когда закончится срок цели направления мы тоже должны удалить из актуал бокса тот же самый объект
и тут появляется вопрос как это реализовать
- отдельный бокс актуальных целей - при добавлении цели в бокс долгосрока направления,
туда тоже добавляется эта цель, тоже самое при удалении. сгенерим отдельно имя бокса, а затем (имяБокса_ключОбъекта)
при таком сценарии надо будет билдер дергать постоянно, чтобы поля ключей изменились


------------
ЗЕМЕТКИ И ВОПРОСЫ

поговорим о инхеритед нотифаер
1. Объявить инхерит. Передать ему в родительский конструктор параметр нотифаер типа changeNotifier
2. Сделать его родительским для виджетов, по которым будем проносить данные
3. Обращаемся к модели в инхерите посредством методов контекста по поиску по дереву. Можно подписаться с 
подпиской и без. поиск без подписки полезен в случае когда из модели нужны константы или какие то методы модели;
с подпиской в случае когда за изменениями данными в моделе нужно следить и менять
4. НотифайЛистенерс. метод перерисовывает только подписанные на него виджеты

почему же даже при использовании инхеритед нотифаер использовали фул виджет
наша задача в чем? - сохранить состояние объявленной модели(changeNotifier), чтобы ее поля не обнулились
прописать переменную модели в билде заведомо странное решение и это очевидно, даже разраб не знает сколько 
раз перевызвоится билд. 
далее, что насчет того чтобы прописать его в поле лесс виджета? в таком случае виджет перестроиться вместе с нашей 
моделью в случае если перестроиться родительский виджет .
ну тогда и остается фул виджет. потому что мы прописываем это поле не в самом виджете, а в его состоянии. 
То есть это поле наша модель уже будет полем состояния. А состоние строится только один раз - при initState()   


где прописывать получение аргументов с другого экрана - didChangeDependencies. ModalRoute - инхерит потому что
но не всегда. можно и в инитСтейт, но тогда уже передача через конструктор проводится

------------
ДНЕВНИК РАЗРАБА(ошибки и как я с ними боролся. планы на день)
Итак написал инит код который преносит все активности в лист. Но это происходит при объявлении модели, 
она в билде, но этот билд не вызывается при pop методе с экаран создания
Решение - в модели activities при инициализации прописать слушатель на бокс( + лист = бокс)
итак при поледнем заходе игрался с подпиской нотифаера на activities. Пришел к выводу
что он обязателен для того чтобы сработал notifyListeners()

была ошибка диапазана при обращении к списку в модели активностей. Исправил 
1) контекст сепарировал 
2) число билдеров - лист.лен, а не рандом число, поэтому и за диапазон уходило

итак. Досматриваю 1 видео. сравню фичи котрые реализованы у него и у меня, все есть ->  иду дальше

на очереди фича удаления...

теперь думаю как это реализовать. удаление происходит на другом экране
1) в виджете будет храниться индекс данной активности, выдается при
  1.1) 2 поля виджета активности заменим на одно поле-модель самой активности

короче, была ошибка бокс уже открыт. 
2 варианта было: 1 - реально открыт бокс что врядли (так как по поиску 
строка открытия бокса только одна в начале). Пытался решить с помощью условий 
открытия этого бокса 
2 - проблема с тем что я корячил модель. С этим я уже пытлася бороться с помощью
полного удаления бокса. Миграция данных не нужна была, тк старые данные не нужны
и щас доигрался до того, что вылетает какая то ошибка видимо связанная с хайв
и приложение банально не запускается(не запускается именно на планшете)

решено. в вацап веб закинул как. а сист ошибка походу была из за импорта dart:js

итак. работаем с фичей чтения направления. на что хочу обратить внимание при просмотре урока в момент
передачи данных
-передача ключа по аргументам
-прием в didChangeDependencies
-из виджета передаем в модель ключ(то есть в состоянии сразу не получится модель проинициализировать)
-проверка в didChangeDependencies на то чтобы модель один раз инициализировалсь
-в модели экрана инит метод состоит из инициализации бокса и метода loadGroup - инит группы. видимо чтобы все 
сразу было доступно

в этой сессии короче подчистил код, убрал лишнее получение ключа. в активити_скрин затолкал в модель саму активити
то есть на экране осталось получение индекса, и инициализация модели, вся инфа в модели. 
провдена работа с моделью которой 'без индекса делать нечего'. Зачем то автор прописал код-проверку на то чтобы 
инициализация модели не произошла дважды и в didChangeDependencies прописал условие if (model==null)

так приступил к работе спустя 2 дня, пока вспоминаю код.
сверяя activity_model заметил :  у автора есть поле с боксом и вызов идет в методе сетап, 
а получение объекта из бокса - отдельный метод. У меня же отдельного поля бокса нет, и получение элкмента идет 
в одну строку; есть геттер на бокс; при инициализации модели на скрине она прописывается в методе билд с методом 
watch, так как билд может вызваться до раскрутки боксов и важно следить за изменениями данных модели

щас исправил свою же ошибку. Как итог - да, индекс не надежная штука когда дело касается чтения значений, которые
есть возможность удалить. Вопрос - почему

сейчас пишу модель для заметок в активности. Итак, есть 2 модели связанные с заметками - экран создания заметки 
NewNoteScreen и экран активити ActivityScreen, где уже идет отображение заметок
Начнем с ActivityScreen
тут нужны методы удаления, добавления, изменения, чтения
теперь 1 попытка настройки отображения заметки. 
1) поставить лист билдер чтобы было с чем работать
------------

